

### Mainlining Databases: Supporting Fast Transactional Workloads on Universal Columnar Data File Formats

* [noisepage](https://db.cs.cmu.edu/papers/2020/p534-li.pdf) [arxiv](https://arxiv.org/abs/2004.14471)

4 Block Transformation

As discussed in Sec. 2.2, the primary obstacle to running transactions on Arrow is write amplification. Our system uses a relaxed Arrow format to achieve good write performance and then uses a lightweight transformation step to put a block into the full Arrow format once it is cold. We now describe this modified format, present our algorithm for transforming them, and discuss the important assumptions and implementation details in NoisePage.

4.1 Relaxed Columnar Format

Typical OLTP workloads modify only a small portion of a database at any given time, while the other parts of the database are mostly accessed by read-only queries [41]. Therefore, for the hot portion, we can trade off read speed for write performance at only a small impact on the overall read performance of the DBMS. To achieve this, we modify the Arrow format for update performance in the hot portion. We detail these changes in this subsection.

Arrow has two sources of write amplification: (1) it disallows gaps in a column, and (2) it stores variable-length values consecutively in a single buffer. Our relaxed format adds a validity bitmap in the block header and additional metadata for each variable-length value to overcome them. As shown in Fig. 5, within a VarlenEntry field, the system maintains 4 bytes for size and 8 bytes for a pointer to the underlying value. Each VarlenEntry is padded to 16 bytes for alignment reasons, and the additional 4 bytes stores a prefix of the value. If a value is shorter than 12 bytes, the system stores it entirely within the object, writing into the pointer. Transactions only access the VarlenEntry instead of Arrow storage directly. Relaxing adherence to Arrow’s format allows the system to only write updates to VarlenEntry, turning a variable-length update into a constant-time fixed-length one, as shown in Fig. 6.

Any readers accessing Arrow storage will be oblivious to the update in VarlenEntry. The system adds a status flag and counter in block headers to coordinate access. A block in NoisePage can be in one of three states – hot, cooling, or frozen. Hot blocks are actively worked on by transactions, whereas frozen blocks are available for in-place scans in the Arrow format; cooling blocks are in the process of being transformed. The access counter on each block functions as a shared latch – each in-place reader adds one to the counter when starting a scan and subtract one when finished. When a transaction updates a frozen block, it first sets that block’s status flag to hot, forcing any future readers to materialize instead of reading in-place. It then spins on the counter and waits for lingering readers to leave the block before proceeding with the update. Once the block is hot, transactional access elide latch protection and rely on the MVCC implementation for thread safety. Other than flipping the flag, there is no transformation process required for a transaction to modify a frozen block because our relaxed format is a generalization of the original Arrow format. Once a block is hot, it remains so until a background process transforms it back to full Arrow compliance.

We now provide an overview of our transformation algorithm, also illustrated in Fig. 7. There are two components of our transformation pipeline, the access observer and block transformer, shown as boxes with dashed lines in Fig. 7. The access observer piggy-backs on the DBMS’s normal garbage collection to inspect recent changes and identify any candidates for transformation to push onto a queue (Sec. 4.2). The block transformer polls from the queue. For correctness reasons, the transformer processes each block at least twice before emitting them as Arrow blocks. The first pass is transactional and rearranges tuples within blocks so that they are contiguous. This transaction passes through the access observer and prompts the access observer to enqueue the block again (Sec. 4.3).